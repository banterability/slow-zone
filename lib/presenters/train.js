// Generated by CoffeeScript 2.2.1
(function() {
  var Dateline, STRING_FIELDS, Train, getNativeBoolean, getNativeDate, getNativeFloat, getNativeInteger;

  Dateline = require('dateline');

  STRING_FIELDS = {
    'destNm': 'destinationName',
    'rt': 'routeId',
    'staNm': 'stationName',
    'stpDe': 'stopDescription'
  };

  Train = class Train {
    constructor(attributes = {}) {
      var attributeName, methodName;
      this.attributes = attributes;
// Map string fields that don't need additional processing
      for (attributeName in STRING_FIELDS) {
        methodName = STRING_FIELDS[attributeName];
        this[methodName] = (function(value) {
          return function() {
            return value;
          };
        })(this.attributes[attributeName]);
      }
    }

    //# Boolean Fields
    isApproaching() {
      return getNativeBoolean(this.attributes.isApp);
    }

    isDelayed() {
      return getNativeBoolean(this.attributes.isDly);
    }

    isFaulty() {
      return getNativeBoolean(this.attributes.isFlt);
    }

    isScheduled() {
      return getNativeBoolean(this.attributes.isSch);
    }

    //# Date Fields
    arrivalTime() {
      return getNativeDate(this.attributes.arrT);
    }

    predictionTime() {
      return getNativeDate(this.attributes.prdt);
    }

    //# Floating Point Fields
    latitude() {
      return getNativeFloat(this.attributes.lat);
    }

    longitude() {
      return getNativeFloat(this.attributes.lon);
    }

    //# Generated Fields
    arrivalMinutes() {
      return Math.round((this.arrivalTime() - this.predictionTime()) / (60 * 1000));
    }

    arrivalString() {
      return Dateline(this.arrivalTime()).getAPTime();
    }

    predictionAge() {
      return Math.round((new Date() - this.predictionTime()) / 1000);
    }

    route() {
      var route;
      switch (route = this.routeId()) {
        case "Brn":
          return "Brown";
        case "G":
          return "Green";
        case "Org":
          return "Orange";
        case "P":
          return "Purple";
        case "Y":
          return "Yellow";
        default:
          return route;
      }
    }

    routeClass() {
      return this.route().toLowerCase();
    }

    //# Integer Fields
    destinationId() {
      return getNativeInteger(this.attributes.destSt);
    }

    directionId() {
      return getNativeInteger(this.attributes.trDr);
    }

    heading() {
      return getNativeInteger(this.attributes.heading);
    }

    runNumber() {
      return getNativeInteger(this.attributes.rn);
    }

    stationId() {
      return getNativeInteger(this.attributes.staId);
    }

    stopId() {
      return getNativeInteger(this.attributes.stpId);
    }

    toHash() {
      return {
        destination: {
          id: this.destinationId(),
          name: this.destinationName()
        },
        location: {
          latitude: this.latitude(),
          longitude: this.longitude(),
          heading: this.heading()
        },
        prediction: {
          arrivalMinutes: this.arrivalMinutes(),
          arrivalString: this.arrivalString(),
          arrivalTime: this.arrivalTime(),
          predictionAge: this.predictionAge(),
          predictionTime: this.predictionTime()
        },
        route: {
          class: this.routeClass(),
          directionId: this.directionId(),
          id: this.routeId(),
          name: this.route(),
          run: this.runNumber()
        },
        station: {
          id: this.stationId(),
          name: this.stationName(),
          stop: {
            id: this.stopId(),
            description: this.stopDescription()
          }
        },
        status: {
          approaching: this.isApproaching(),
          delayed: this.isDelayed(),
          faulty: this.isFaulty(),
          scheduled: this.isScheduled()
        }
      };
    }

  };

  module.exports = Train;

  //# Helpers
  getNativeBoolean = function(booleanString) {
    return getNativeInteger(booleanString) === 1;
  };

  getNativeDate = function(timeString) {
    var day, hour, min, month, sec, str, year;
    [str, year, month, day, hour, min, sec] = timeString.match(/(\d{4})(\d{2})(\d{2}) (\d{2}):(\d{2}):(\d{2})/);
    return new Date(year, month - 1, day, hour, min, sec);
  };

  getNativeFloat = function(floatString) {
    return parseFloat(floatString);
  };

  getNativeInteger = function(integerString) {
    return parseInt(integerString, 10);
  };

}).call(this);
